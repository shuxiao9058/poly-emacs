#+title: Programming

Configuration for programming and languages support.

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src

* Format

#+begin_src emacs-lisp

(use-package format-all
  ;; :straight t
  :straight (:host github :repo "shuxiao9058/emacs-format-all-the-code")
  :ensure t
  :hook ((
	  fish-mode
	  sh-mode
	  ;; prog-mode
	  lua-mode
	  go-mode
	  python-mode
	  java-mode
	  cc-mode
	  c-mode
	  c++-mode
	  clang-mode
	  elisp-mode
	  emacs-lisp-mode
	  markdown-mode
	  yaml-mode
	  nix-mode
	  protobuf-mode
	  nginx-mode
	  cperl-mode
	  clojure-mode
	  ;;  objc-mode
	  ;;  swift-mode
	  ;;  typescript-mode
	  ;;  web-mode
	  ) . format-all-mode)
  :commands (format-all-mode
	     format-all-buffer)
  ;; :custom
  :init
  (defconst format-all--system-type
    (cl-case system-type
      (windows-nt 'windows)
      (cygwin     'windows)
      (darwin     'macos)
      (gnu/linux  'linux)
      (berkeley-unix
       (save-match-data
	 (let ((case-fold-search t))
	   (cond ((string-match "freebsd" system-configuration) 'freebsd)
		 ((string-match "openbsd" system-configuration) 'openbsd)
		 ((string-match "netbsd"  system-configuration) 'netbsd))))))
    "Current operating system according to the format-all package.")

  (defun format-all--resolve-system (choices)
    "Get first choice matching `format-all--system-type' from CHOICES."
    (cl-dolist (choice choices)
      (cond ((atom choice)
	     (cl-return choice))
	    ((eql format-all--system-type (car choice))
	     (cl-return (cadr choice))))))
  :config
  (define-format-all-formatter cpp-lua-format
    (:executable "lua-format")
    (:install (macos ""))
    (:languages "Lua")
    (:features)
    (:format (format-all--buffer-easy executable "-i" "-c" (expand-file-name "~/.config/lua-format/config.yaml") "--")))

  (define-format-all-formatter my-clang-format
    (:executable "clang-format")
    (:install
     (macos "brew install clang-format")
     (windows "scoop install llvm"))
    (:languages "C" "C++" "Java" "Objective-C" "Protocol Buffer")
    (:features)
    (:format
     (format-all--buffer-easy
      executable
      (concat "-assume-filename="
	      (or (buffer-file-name)
		  (cdr (assoc language
			      '(("C"               . ".c")
				("C++"             . ".cpp")
				("Java"            . ".java")
				("Objective-C"     . ".m")
				("Objective-C" . ".x")
				("Objective-C" . ".xm")
				("Objective-C" . ".m")
				("Objective-C" . ".mm")
				("Protocol Buffer" . ".proto")))))))))

  (define-format-all-formatter goimports-gofmt
    (:executable "/bin/sh")
    (:install
     (macos "brew install go")
     (windows "scoop install go")
     "go get golang.org/x/tools/cmd/goimports")
    (:languages "Go")
    (:features)
    (:format (format-all--buffer-easy executable "-c" "goimports | gofmt -s")))


  (define-format-all-formatter goimports
    (:executable "goimports")
    (:install (macos ""))
    (:languages "Go")
    (:features)
    (:format (format-all--buffer-easy executable)))

  (define-format-all-formatter gofumpt
    (:executable "gofumpt")
    ;; (:executable "/bin/sh")
    (:install (macos ""))
    (:languages "Go")
    (:features)
    (:format (format-all--buffer-easy executable)))

  (define-format-all-formatter my-shfmt
    (:executable "shfmt")
    (:install
     (macos "brew install shfmt")
     (windows "scoop install shfmt"))
    (:languages "Shell")
    (:features)
    (:format
     (format-all--buffer-easy executable "-i" "4" "-ci"
			      (if (buffer-file-name)
				  (list "-filename" (buffer-file-name))
				(list "-ln"
				      (cl-case (and (eql major-mode 'sh-mode)
						    (boundp 'sh-shell)
						    (symbol-value 'sh-shell))
					(bash "bash")
					(mksh "mksh")
					(t "posix")))))))


  ;; (define-format-all-formatter nginxfmt
  ;; 	(:executable "nginxfmt")
  ;;   (:install (macos "pip install nginxfmt"))
  ;;   ;; (:install
  ;;   ;;  (macos "brew install shfmt")
  ;;   ;;  (windows "scoop install shfmt"))
  ;;   (:languages "_Nginx")
  ;;   ;; (:modes nginx-mode)
  ;;   (:features)
  ;;   (:format
  ;;    (format-all--buffer-easy executable "-i" "4" "-")))

  ;; (define-format-all-formatter crossplane
  ;; 	(:executable "/usr/local/bin/nginx_format.sh")
  ;;   (:install (macos "pip install crossplane"))
  ;;   (:languages "Nginx")
  ;;   (:features)
  ;;   ;; (:modes nginx-mode)
  ;;   (:format (format-all--buffer-easy executable)))

  ;; lsp-format-buffer

  (eval-after-load 'format-all
    (dolist (hook '(lua-mode-hook
		    ;; go-mode-hook
		    python-mode-hook
		    java-mode-hook
		    markdown-mode-hook
		    ;; cc-mode-hook
		    ;; c-mode-hook
		    ;; c++-mode-hook
		    ;; clang-mode-hook
		    ;; objc-mode-hook
		    nginx-mode-hook
		    emacs-lisp-mode-hook
		    markdown-mode-hook
		    fish-mode-hook
		    protobuf-mode-hook))
      (add-hook hook 'format-all-ensure-formatter)))

  (setq-default format-all-formatters
		'(
		  ("Go" gofumpt)
		  ;; ("Go" goimports)
		  ("Lua" cpp-lua-format)
		  ("Java" my-clang-format)
		  ("Markdown" prettier)
		  ("C" my-clang-format)
		  ("C++" my-clang-format)
		  ;; ("Objective-C" my-clang-format)
		  ("Protocol Buffer" my-clang-format)
		  ("SQL" pgformatter)
		  ;; ("CSS" prettier)
		  ;; ("HTML" prettier)
		  ;; ("Dockerfile" dockfmt)
		  ("Shell" my-shfmt)
		  ;; ("Markdown" prettier)
		  ("Nix" nixpkgs-fmt)
		  ;; ("Emacs Lisp" emacs-lisp)
		  ;; ("YAML" prettier)
		  ;; ("Nginx" nginx-fmt)
		  )))
#+end_src

* Flycheck

#+begin_src emacs-lisp
  (straight-use-package 'flycheck)
  (straight-use-package 'flycheck-pos-tip)

  (with-eval-after-load 'flycheck
    (flycheck-pos-tip-mode))
#+end_src

* LSP

** eglot

Use eglot as LSP client.

#+begin_src emacs-lisp

;; https://github.com/DEbling/dotfiles/blob/9dc0e347267dd68111baf8e7ab7d33c2e39ed404/.emacs.d/elisp/lang-java.el
;; (defconst jdt-jar-path "~/.emacs.d/.local/jar/org.eclipse.equinox.launcher.jar")
;; (defconst jdt-jar-path "/opt/jdt-language-server/plugins/org.eclipse.equinox.launcher_1.6.0.v20200915-1508.jar")
(defconst jdt-jar-path (expand-file-name "jdt-language-server/plugins/org.eclipse.equinox.launcher_1.6.400.v20210924-0641.jar" "~/workspace"))
(defconst jdt-extra-jvm-args '("-noverify"
			       "-javaagent:/Users/jiya/workspace/dotemacs.d/.local/jar/lombok.jar"
			       ;; "-javaagent:[~/.emacs.d/.local/jar/lombok.jar][classes=META-INF/]"
			       "-Xbootclasspath/a:~/.config/emacs/.local/jar/lombok.jar"
			       "--add-modules=ALL-SYSTEM"
			       "--add-opens"
			       "java.base/java.util=ALL-UNNAMED"
			       "--add-opens"
			       "java.base/java.lang=ALL-UNNAMED"
			       ;; "-configuration"
			       ;; "/opt/jdt-language-server/config_mac"
			       ))

(defun my-eclipse-jdt-contact (interactive)
  "Contact with the jdt server.
If INTERACTIVE, prompt user for details."
  (let* ((cp (getenv "CLASSPATH"))
	 (contact (unwind-protect (progn
				    (setenv "CLASSPATH" jdt-jar-path)
				    (eglot--eclipse-jdt-contact interactive))
		    (setenv "CLASSPATH" cp)))
	 (jdt-class (car contact))
	 (args (cddr contact)))
    (append (list jdt-class "/usr/bin/java")
	    jdt-extra-jvm-args args)))
;; (setq aaabb (my-eclipse-jdt-contact))

(defun dart-lsp-contact (interactive)
  (list (executable-find "dart")
        (concat (file-name-directory (nix-executable-find nil "dart"))
                "snapshots/analysis_server.dart.snapshot")
        "--lsp"
        "--client-id=emacs.eglot"))

(use-package eglot
  :straight t
  :hook ((go-mode lua-mode beancount-mode python-mode c-mode c++-mode python-mode java-mode) . eglot-ensure)
  :custom
  (eglot-stay-out-of '(flymake imenu eldoc))  ;; eglot reinits backends
  (eglot-autoshutdown t)
  (eglot-sync-connect 1)
  (eglot-connect-timeout 40)
  (eglot-send-changes-idle-time 0.5)
  (eglot-confirm-server-initiated-edits nil)
  ;; (eglot-events-buffer-size 500000)
  (eglot-events-buffer-size 0)
  ;; disable symbol highlighting and documentation on hover
  (eglot-ignored-server-capabilites
   '(:documentHighlightProvider
     :signatureHelpProvider
     :hoverProvider))
  ;; NOTE We disable eglot-auto-display-help-buffer because :select t in
  ;; its popup rule causes eglot to steal focus too often.
  (eglot-auto-display-help-buffer nil)
  :functions eglot--eclipse-jdt-contact
  :config
  (setq eldoc-echo-area-use-multiline-p nil)
  (setq eglot-workspace-configuration
        '((:gopls .
		  (:usePlaceholders t
				    :completeUnimported  t
				    :experimentalWorkspaceModule t
				    ;; :experimentalDiagnosticsDelay "800ms"
				    ))))
  ;; emmylua
  (let ((emmylua-jar-path (expand-file-name "bin/EmmyLua-LS-all.jar" poly-local-dir)))
    (add-to-list 'eglot-server-programs
		 `(lua-mode  . ("/usr/bin/java" "-cp" ,emmylua-jar-path "com.tang.vscode.MainKt"))))

  (add-to-list 'eglot-server-programs
	       '(java-mode .  my-eclipse-jdt-contact))

  (add-to-list 'eglot-server-programs
	       `(beancount-mode .  ("beancount-language-server")))

  (add-to-list 'eglot-server-programs
	       '(dart-mode . dart-lsp-contact))

  (when (executable-find "ccls")
    (add-to-list 'eglot-server-programs '((c-mode c++-mode) "ccls"
 					  "-init={\"compilationDatabaseDirectory\":\"build\"}")))
  (when (executable-find "gopls")
    (add-to-list 'eglot-server-programs '(go-mode . ("gopls"))))

  (add-hook 'eglot-managed-mode-hook
	    (lambda()
	      (progn
                (lsp/non-greedy-eglot)
                (lsp/extra-capf))
	      ;; (make-local-variable 'completion-at-point-functions)
	      ;; (setq-local completion-at-point-functions
	      ;; 		  '(tabnine-completion-at-point cape-line cape-symbol cape-ispell cape-dabbrev cape-tex cape-file tags-completion-at-point-function))
	      ))

  ;; (add-hook 'eglot-managed-mode-hook
  ;; 	    (lambda()
  ;; 	      (make-local-variable 'company-backends)
  ;; 	      (setq-local company-backends
  ;; 			  '(company-tabnine-capf company-capf company-tabnine
  ;; 						 (company-dabbrev company-dabbrev-code)
  ;; 						 company-keywords company-files))))
  ;; (add-hook 'eglot-managed-mode-hook (lambda()
  ;; 				       (make-local-variable 'company-backends)
  ;; 				       ;; (setq-local company-backends nil)
  ;; 				       ;; (setq company-backends
  ;; 				       ;; 	     '(company-capf
  ;; 				       ;; 	       ;; company-dabbrev-code
  ;; 				       ;; 	       (company-files          ; files & directory
  ;; 				       ;; 		company-keywords       ; keywords
  ;; 				       ;; 		)
  ;; 				       ;; 	       (company-abbrev company-dabbrev)))
  ;; 				       (setq-local company-backends
  ;; 						   ;; '((company-tabnine :with company-capf :separate)
  ;; 						   '(company-tabnine
  ;; 						     company-dabbrev-code
  ;; 						     (company-files          ; files & directory
  ;; 						      company-keywords       ; keywords
  ;; 						      )
  ;; 						     (company-abbrev company-dabbrev)))
  ;; 				       ))
  ;; )
  :bind (:map eglot-mode-map
	      ("C-c C-r" . eglot-rename)
	      ("C-c C-a" . eglot-code-actions)
	      ("C-c C-f" . eglot-format-buffer))
  )


(defun lsp/non-greedy-eglot ()
  "Making Eglot capf non-greedy."
  (progn
    (fset 'non-greedy-eglot
          (cape-capf-buster
           (cape-capf-properties #'eglot-completion-at-point :exclusive 'no)))
    (setq completion-at-point-functions
          (list #'non-greedy-eglot))))

(defun lsp/extra-capf ()
  "Adding extra capf during LSP startup."
  (let ((tmp-symbol (intern (concat "capf/" (symbol-name major-mode)))))
    (unless (null (symbol-function tmp-symbol))
      (funcall (symbol-function tmp-symbol)))))
#+end_src

*** Key Binding

#+begin_src emacs-lisp
  (define-key toggle-map "L" 'eglot)
#+end_src

* Clojure

** clojure-mode

Use clojure-mode for basic syntax support.

#+begin_src emacs-lisp
  (straight-use-package 'clojure-mode)

  (setq clojure-toplevel-inside-comment-form t)

  (with-eval-after-load "clojure-mode"
    (define-clojure-indent
      (re-frame/reg-event-fx :defn)
      (re-frame/reg-event-db :defn)
      (re-frame/reg-sub :defn)
      (re-frame/reg-fx :defn)
      (t/async :defn)
      (defclass '(1 :defn))))
#+end_src

** Fix clojure syntax highlighting

#+begin_src emacs-lisp
  (with-eval-after-load "clojure-mode"
    (setq clojure-font-lock-keywords
          (eval-when-compile
            `(;; Function definition (anything that starts with def and is not
              ;; listed above)
              (,(concat "(\\(?:" clojure--sym-regexp "/\\)?"
                        "\\(def[^ \r\n\t]*\\)"
                        ;; Function declarations
                        "\\>"
                        ;; Any whitespace
                        "[ \r\n\t]*"
                        ;; Possibly type or metadata
                        "\\(?:#?^\\(?:{[^}]*}\\|\\sw+\\)[ \r\n\t]*\\)*"
                        (concat "\\(" clojure--sym-regexp "\\)?"))
               (1 font-lock-keyword-face)
               (2 font-lock-function-name-face nil t))
              ;; (fn name? args ...)
              (,(concat "(\\(?:clojure.core/\\)?\\(fn\\)[ \t]+"
                        ;; Possibly type
                        "\\(?:#?^\\sw+[ \t]*\\)?"
                        ;; Possibly name
                        "\\(\\sw+\\)?" )
               (1 font-lock-keyword-face)
               (2 font-lock-function-name-face nil t))
              ;; Global constants - nil, true, false
              (,(concat
                 "\\<"
                 (regexp-opt
                  '("true" "false" "nil") t)
                 "\\>")
               0 font-lock-constant-face)
              ;; Special forms
              (,(concat
                 "("
                 (regexp-opt
                  '("def" "do" "if" "let" "let*" "var" "fn" "fn*" "loop" "loop*"
                    "recur" "throw" "try" "catch" "finally"
                    "set!" "new" "."
                    "monitor-enter" "monitor-exit" "quote") t)
                 "\\>")
               1 font-lock-keyword-face)
              ;; Built-in binding and flow of control forms
              (,(concat
                 "(\\(?:clojure.core/\\)?"
                 (regexp-opt
                  '("letfn" "case" "cond" "cond->" "cond->>" "condp"
                    "for" "when" "when-not" "when-let" "when-first" "when-some"
                    "if-let" "if-not" "if-some"
                    ".." "->" "->>" "as->" "doto" "and" "or"
                    "dosync" "doseq" "dotimes" "dorun" "doall"
                    "ns" "in-ns"
                    "with-open" "with-local-vars" "binding"
                    "with-redefs" "with-redefs-fn"
                    "declare") t)
                 "\\>")
               1 font-lock-keyword-face)
              ;; Character literals - \1, \a, \newline, \u0000
              ("\\\\\\([[:punct:]]\\|[a-z0-9]+\\>\\)" 0 'clojure-character-face)

              (,(format "\\(:\\{1,2\\}\\)\\([^%s]+\\)" clojure--sym-forbidden-rest-chars)
               (1 'clojure-keyword-face)
               (2 'clojure-keyword-face))

              ;; #_ and (comment ...) macros.
              (clojure--search-comment-macro 1 font-lock-comment-face t)
              ;; Highlight `code` marks, just like `elisp'.
              (,(rx "`" (group-n 1 (optional "#'")
                                 (+ (or (syntax symbol) (syntax word)))) "`")
               (1 'font-lock-constant-face prepend))
              ;; Highlight [[var]] comments
              (,(rx "[[" (group-n 1 (optional "#'")
                                  (+ (or (syntax symbol) (syntax word)))) "]]")
               (1 'font-lock-constant-face prepend))
              ;; Highlight escaped characters in strings.
              (clojure-font-lock-escaped-chars 0 'bold prepend)
              ;; Highlight grouping constructs in regular expressions
              (clojure-font-lock-regexp-groups
               (1 'font-lock-regexp-grouping-construct prepend))))))
#+end_src

** Cider for REPL connection

#+begin_src emacs-lisp
  (straight-use-package 'cider)

  (autoload 'cider-jack-in "cider" nil t)

  (setq cider-offer-to-open-cljs-app-in-browser nil)

  (with-eval-after-load "cider"
    (define-key cider-mode-map (kbd "C-c C-f") nil))
#+end_src

** Linting with flycheck-clj-kondo

#+begin_src emacs-lisp
  (straight-use-package 'flycheck-clj-kondo)

  (add-hook 'clojure-mode-hook 'flycheck-mode)
#+end_src

** Format code with zprint

#+begin_src emacs-lisp
  (straight-use-package '(zprint :type git
                                 :host github
                                 :repo "DogLooksGood/zprint.el"))

  (autoload 'zprint "zprint" nil t)

  (with-eval-after-load "clojure-mode"
    (define-key clojure-mode-map (kbd "C-c C-f") 'zprint))
#+end_src

* Rust
** rust-mode
#+begin_src emacs-lisp
  (straight-use-package 'rust-mode)
#+end_src

** Use LSP

#+begin_src emacs-lisp
  (with-eval-after-load "lsp-mode"
    (add-hook 'rust-mode-hook 'lsp))
#+end_src

* HTML
#+begin_src emacs-lisp
  (setq-default css-indent-offset 2
                js-indent-level 2)
#+end_src

** Emmet
#+begin_src emacs-lisp
  (straight-use-package 'emmet-mode)

  (autoload 'emmet-expand-line "emmet-mode" nil t)

  (with-eval-after-load "mhtml-mode"
    (define-key mhtml-mode-map (kbd "M-RET") 'emmet-expand-line))

#+end_src
