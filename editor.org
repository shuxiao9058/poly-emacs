#+title: Editor Basics

Configuration for editor basics.

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src

* Package management

** Straight

Straight.el is used for package management.
Bind some keys for quick operations.

* Better defaults

This is consulted on every `require', `load' and various path/io functions.  You get a minor speed up by nooping this.

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      ;; auth-sources '("~/.authinfo")
      make-backup-files nil
      enable-local-eval t
      enable-local-variables :all
      bookmark-default-file (expand-file-name "bookmarks" poly-cache-dir)
      prescient-save-file (expand-file-name "prescient-save.el" poly-cache-dir)
      ;; auto-save-default nil
      ;; auto-save-list-file-prefix nil
      auto-save-list-file-prefix (expand-file-name "auto-save-list/save-" poly-cache-dir)
      save-silently t
      find-file-suppress-same-file-warnings t
      vc-follow-symlinks t
      inhibit-startup-screen t
      whitespace-line-column 100
      default-directory (expand-file-name "workspace/" "~")
      vagrant-vagrantfile (expand-file-name "vagrant/Vagrantfile" default-directory)
      max-lisp-eval-depth 10000
      ;; Wrapping
      truncate-lines t
      truncate-partial-width-windows 50
      whitespace-style '(face trailing lines-tail)
      xref-prompt-for-identifier nil)

;; @see https://github.com/emacs-lsp/lsp-mode#performance
(setq read-process-output-max (* 3 1024 1024))

;; Suppress warning when opening large files
(setq large-file-warning-threshold nil)

 (setq ring-bell-function 'ignore)

; From Mastering Emacs
;; https://masteringemacs.org/article/working-coding-systems-unicode-emacs
;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

;; Enable disabled command
(setq disabled-command-function nil)

;; ;;; lisp
;; (setq ;; lisp-body-indent   2
;;  lisp-indent-function  'lisp-indent-function)

;; enable C-x C-u to upcase-region
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'set-goal-column 'disabled nil)
#+end_src

** Encoding
#+begin_src emacs-lisp
;; handle emacs utf-8 input
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(prefer-coding-system 'utf-8)
(setenv "LANG" "en_US.UTF-8")
#+end_src

#+begin_src emacs-lisp
(unless noninteractive
  (setq file-name-handler-alist nil))
#+end_src

Disable startup-screen and message
#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
#+end_src

Makes *scratch* empty.
#+begin_src emacs-lisp
(setq initial-scratch-message nil)
#+end_src

Don't show *Buffer list* when opening multiple files at the same time.

#+begin_src emacs-lisp
(setq inhibit-startup-buffer-menu t)
#+end_src

 Delete trailing whitespace before save

#+begin_src emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src

* Completion for key sequence

** Which-key

* Minibuffer completion reading
**  Vertico & Orderless

- Vertico provides a better UX for completion reading.
- Orderless provides a completion style, which allows you to search with orderless segments.


Enable orderless for minibuffer completion.

* Completion at point

* Templating

** yasnippet

Expand template with =TAB=. Jump between the placeholders with =TAB= and =S-TAB=.

* Project management

** perspective

#+begin_src emacs-lisp
(use-package perspective
  :straight t
  :demand t
  :commands
  (persp-mode)
  :config
  (persp-mode)
  :bind
  ("C-x C-b" . persp-list-buffers)         ; or use a nicer switcher, see below
  :custom
  (persp-mode-prefix-key (kbd "C-c M-p"))  ; pick your own prefix key here
  )

(use-package persp-projectile
  :straight t)
#+end_src

** project.el

To find files/buffers and apply commands on project, use builtin package ~project~.

#+begin_src emacs-lisp
(use-package project
  :straight nil
  :custom
  (project-vc-ignores
   '("vendor/" "*.elc" "*.a"
     "tmp" "dist" "coverage"
     ".idea" ".vscode"
     ".ensime_cache" ".eunit"
     ".git" ".hg" ".fslckout"
     "_FOSSIL_" ".bzr" "_darcs"
     ".tox" ".svn"
     ".stack-work" ".ccls-cache" ".cache" ".clangd")
   '(".log" ".vs" "node_modules")))

(use-package ag
  :straight t
  :ensure t
  :commands (ag ag-regexp ag-project)
  :custom
  (ag-highlight-search t)
  (ag-reuse-buffers t)
  (ag-reuse-window t))

(defcustom find-project-ignore-dir
  '("/usr")
  ""
  :type 'list)


(defun my/projectile-ignored-project-function(project-root)
  (member t (mapcar
	     #'(lambda (dir)
		 (string-prefix-p dir project-root)
		 )
	     find-project-ignore-dir
	     )))


(defun projectile-selection-at-point ()
  (when (use-region-p)
    (buffer-substring-no-properties (region-beginning) (region-end))))

(defun projectile-deadgrep (search-term)
  (interactive (list (deadgrep--read-search-term)))
  (let ((deadgrep-project-root-function #'projectile-project-root))
    (deadgrep search-term)))

(use-package projectile
  :straight t
  :commands projectile-global-mode
  :after rg
  :delight '(:eval (format " [prj: %s]" (projectile-project-name)))
  ;; :init
  ;; (when (executable-find "rg")
  ;;   (setq-default projectile-generic-command "rg --files --hidden"))
  ;; :delight
  :preface
  :custom
  (projectile-buffers-filter-function 'projectile-buffers-with-file-or-process)
  (projectile-indexing-method 'hybrid)
  (projectile-completion-system 'default)
  (projectile-ignored-project-function #'my/projectile-ignored-project-function)
  (projectile-enable-caching t)
  (projectile-sort-order 'recently-active)
  ;; (projectile-sort-order 'modification-time)
  ;; (projectile-search-in-file-rg  (lambda () (projectile-dired) (projectile-commander)))
  ;; (projectile-switch-project-action  (lambda () (projectile-dired) (projectile-commander)))
  ;; :preface
  ;; (defun projectile-rg ()
  ;;   "Run ripgrep in projectile."
  ;;   (interactive)
  ;;   (counsel-rg "" (projectile-project-root))
  ;;   )
  :config
  (defun poly/switch-project-action ()
    (interactive)
    (if (magit-git-dir)
	(magit-status)
      (projectile-find-file)))

  (defun my/projectile-dynamic-change-index-method()
    (when (projectile-project-p)
      (if (eq (projectile-project-vcs) 'none)
	  (setq projectile-indexing-method 'native)
	(setq projectile-indexing-method 'hybrid))))

  (add-hook 'find-file-hook #'my/projectile-dynamic-change-index-method)
  (add-hook 'dired-mode-hook #'my/projectile-dynamic-change-index-method)

  (defun reload-dir-locals-for-project ()
    "For every buffer with the same `projectile-project-root' as the
current buffer's, reload dir-locals."
    (interactive)
    (dolist (buffer (projectile-project-buffer-names))
      (with-current-buffer buffer
	(reload-dir-locals-for-curent-buffer))))


  ;; `ibuffer-projectile'
  (add-hook 'ibuffer-hook
	    (lambda ()
	      (ibuffer-projectile-set-filter-groups)
	      (unless (eq ibuffer-sorting-mode 'alphabetic)
		(ibuffer-do-sort-by-alphabetic))))

  (my/projectile-ignored-project-function "/usr/bin")
  (my/projectile-ignored-project-function "vendor")

  ;; (setq projectile-switch-project-action #'poly/switch-project-action)

  (defun my/projectile-custom-switch-action()
    (my/projectile-dynamic-change-index-method)
    (projectile-find-file))

  (setq projectile-switch-project-action #'my/projectile-custom-switch-action)

  (setq projectile-cache-file (expand-file-name "projectile.cache" poly-cache-dir)
	projectile-known-projects-file (concat poly-cache-dir "projectile-bookmarks.eld"))
  (setq projectile-globally-ignored-directories
	'(".idea"
	  ".ensime_cache"
	  ".eunit"
	  ".extension"
	  ".git"
	  ".hg"
	  ".fslckout"
	  "_FOSSIL_"
	  ".bzr"
	  ".vagrant"
	  "_darcs"
	  "archive-contents"
	  "cache"
	  "target"
	  "coverage"
	  ".tox"
	  ".settings"
	  ".svn"
	  ".github"
	  ".metals"
	  ".bloop"
	  ".ccls-cache"
	  ".stack-work"
	  "doc"
	  "docs"
	  "elpa"
	  "log"
	  "logs"
	  "node_modules"
	  "sorbet"
	  "straight"
	  "tmp"
	  "vendor/assets")
	projectile-globally-ignored-file-suffixes '("*.pyc" "*.class" "*.project" "*.jar")
	projectile-globally-ignored-files '("TAGS" "*.log"))
  ;; Use the faster searcher to handle project files: ripgrep `rg'.
  (when (and (not (executable-find "fd"))
	     (executable-find "rg"))
    (setq projectile-generic-command
	  (let ((rg-cmd ""))
	    (dolist (dir projectile-globally-ignored-directories)
	      (setq rg-cmd (format "%s --glob '!%s'" rg-cmd dir)))
	    (dolist (extfs projectile-globally-ignored-file-suffixes)
	      (setq rg-cmd (format "%s -g '!%s'" rg-cmd extfs)))
	    (concat "rg -0 --files --color=never --hidden" rg-cmd))))
  (projectile-global-mode)
  :bind (
	 :map projectile-command-map
	 ("s s" . projectile-deadgrep)))

(defun poly/find-file()
  "my find file"
  (interactive)
  (if (and (bound-and-true-p projectile-mode) (not (eq (projectile-project-vcs) 'none)))
      (projectile-find-file)
    (call-interactively #'find-file)
    ))

(defun my-filter-buffer(buffers)
  (cl-remove-if
   (lambda (b)
     (let ((buf-name (buffer-file-name b)))
       (if buf-name
	   (string-match-p (buffer-file-name b) "\\`\\*")
	 t))) buffers))

(defun poly/switch-to-buffer()
  "my find file"
  (interactive)
  (if (and (bound-and-true-p projectile-mode) (not (eq (projectile-project-vcs) 'none)))
      (let ((projectile-buffers-filter-function #'projectile-buffers-with-file))
	(projectile-switch-to-buffer))
    (call-interactively #'switch-to-buffer)
    ))
#+end_src

* Enanced completion commands

** consult

* Text searching

** COMMENT deadgrep

** rg.el

#+begin_src emacs-lisp
(use-package rg
  :straight t
  ;; :hook (rg-mode . wgrep-ag-setup)
  :custom
  (rg-custom-type-aliases
   '(("clojure" . "*.clj *.cljs *.cljc *.cljx *.edn")))
  (rg-group-result t)
  (rg-show-columns t)
  (rg-ignore-case 'smart)
  (rg-show-header t)
  :config
  (rg-enable-default-bindings)
  ;; (rg-define-search bl/rg-regexp-project
  ;;   :query ask
  ;;   :format regexp
  ;;   :files current
  ;;   :dir project
  ;;   :confirm never)
  )
#+end_src
* tab-bar

Tab bar represents a named persistent window configuration.

#+begin_src emacs-lisp
(use-package tab-bar
  :straight nil
  :custom
  (tab-bar-close-button-show nil)
  (tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (tab-bar-close-tab-select 'recent)
  ;; Start a new tab with the current buffer.
  (tab-bar-new-tab-choice t)
  (tab-bar-new-tab-to 'right)
  (tab-bar-position nil)
  ;; Keep tab-bar hidden.
  (tab-bar-show t)
  (tab-bar-tab-hints t)
  ;; (tab-bar-tab-name-function 'tab-bar-tab-name-all)
  (tab-bar-border 0)
  (tab-bar-close-button nil)
  (tab-bar-back-button nil)
  (tab-bar-new-button nil)
  (tab-bar-format '(tab-bar-format-tabs))
  (tab-bar-tab-name-format-function '+tab-bar-tab-format-function)
  :config
  ;; Enable `tab-bar-mode' by default.
  (tab-bar-mode t)
  (global-tab-line-mode -1)
  ;; Check `winner-mode' that keeps track of layout changes.
  (tab-bar-history-mode -1)

  (defun my/tab-bar-select-tab-dwim ()
    "Do-What-I-Mean function for getting to a `tab-bar-mode' tab.
If no other tab exists, create one and switch to it.  If there is
one other tab (so two in total) switch to it without further
questions.  Else use completion to select the tab to switch to."
    (interactive)
    (let ((tabs (mapcar (lambda (tab)
			  (alist-get 'name tab))
			(tab-bar--tabs-recent))))
      (cond ((eq tabs nil)
	     (tab-new))
	    ((eq (length tabs) 1)
	     (tab-next))
	    (t
	     (tab-bar-switch-to-tab (completing-read "Select tab: " tabs))))))

  (defun +tab-bar-switch-project ()
    "Switch to project in a new tab, project name will be used as tab name.
No tab will created if the command is cancelled."
    (interactive)
    (let (succ)
      (unwind-protect
	  (progn
	    (tab-bar-new-tab)
	    (call-interactively #'project-switch-project)
	    (when-let ((proj (project-current)))
	      (tab-bar-rename-tab (format "%s" (file-name-nondirectory (directory-file-name (cdr proj)))))
	      (setq succ t)))
	(unless succ
	  (tab-bar-close-tab)))))

  (defun +tab-bar-tab-format-function (tab i)
    (let ((current-p (eq (car tab) 'current-tab)))
      (concat
       (propertize (concat
		    " "
		    (alist-get 'name tab)
		    " ")
		   'face
		   (funcall tab-bar-tab-face-function tab))
       " ")))

  (global-set-key (kbd "C-x t .") #'tab-bar-rename-tab)
  (global-set-key (kbd "C-x t l") #'+tab-bar-switch-project)

  (tab-bar-mode 1)
  :bind
  ("H-t" . an/hydra-window-management/body)
  ("C-x t t" . my/tab-bar-select-tab-dwim)
  ("s-t" . tab-new)
  ("s-<left>" . tab-previous)
  ("s-<right>" . tab-next)
  ;; monkey-with-hammer.png
  ("s-1" .  (lambda () (interactive) (tab-bar-select-tab 1)))
  ("s-2" .  (lambda () (interactive) (tab-bar-select-tab 2)))
  ("s-3" .  (lambda () (interactive) (tab-bar-select-tab 3)))
  ("s-4" .  (lambda () (interactive) (tab-bar-select-tab 4)))
  ("s-5" .  (lambda () (interactive) (tab-bar-select-tab 5)))
  ("s-6" .  (lambda () (interactive) (tab-bar-select-tab 6)))
  ("s-7" .  (lambda () (interactive) (tab-bar-select-tab 7)))
  ("s-8" .  (lambda () (interactive) (tab-bar-select-tab 8)))
  ("s-9" .  (lambda () (interactive) (tab-bar-select-tab 9))))

;; use project name as default tab name
(defun toy/set-tab-name-default ()
  (interactive)
  (if (buffer-file-name (current-buffer))
      (let ((proj-name (projectile-project-name)))
	(unless (or (= (length proj-name) 0) (string= proj-name "-"))
	  ;; (message proj-name)
	  (tab-bar-rename-tab proj-name)))))

(advice-add 'tab-bar-new-tab :after (lambda (&rest x) (toy/set-tab-name-default)))
(advice-add 'tab-bar-tab-name-format-function :after (lambda (&rest x) (toy/set-tab-name-default)))
(add-hook 'window-setup-hook #'toy/set-tab-name-default)
#+end_src


* Window Management

** ace

#+begin_src emacs-lisp

;; winum users can use `winum-select-window-by-number' directly.
(defun my-select-window-by-number (win-id)
  "Use `ace-window' to select the window by using window index.
WIN-ID : Window index."
  (let ((wnd (nth (- win-id 1) (aw-window-list))))
    (if wnd
	(aw-switch-to-window wnd)
      (message "No such window."))))

(defun my-select-window ()
  (interactive)
  (let* ((event last-input-event)
	 (key (make-vector 1 event))
	 (key-desc (key-description key)))
    (my-select-window-by-number
     (string-to-number (car (nreverse (split-string key-desc "-")))))))

(use-package ace-window
  :straight t
  :ensure t
  :defer t
  :init
  (global-set-key [remap other-window] #'ace-window)
  :custom
  (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-scope 'global)
  (aw-background t)
  :bind
  (("C-x o" . ace-window)))

;;;###autoload
(defun ace-maximize-window ()
  "Ace maximize window."
  (interactive)
  (select-window (aw-select " Ace - Maximize Window"))
  (delete-other-windows))
#+end_src

** windswap

#+begin_src emacs-lisp
(use-package windswap
  :straight t
  ;; https://github.com/amnn/windswap
  ;; windswap-left|right|up|down
  :commands (windswap-up windswap-down windswap-left windswap-right))
#+end_src

** move frame to side

#+begin_src emacs-lisp

(defun current-monitor-pixel-dimensions ()
  (let* ((monitor-attributes (display-monitor-attributes-list
			      (frame-parameter nil 'display))))
    (list (nth 3 (assq 'geometry (nth 0 monitor-attributes)))
	  (nth 4 (assq 'geometry (nth 0 monitor-attributes))))))

;; (defun current-monitor-pixel-width ()
;;   (car (current-monitor-pixel-dimensions)))

;; (defun current-monitor-pixel-height ()
;;   (nth 1 (current-monitor-pixel-dimensions )))

(defun move-frame-left-or-right-side (left)
  (when (display-graphic-p)
    (let* ((frame (selected-frame))
	   (fullscreen (frame-parameter frame 'fullscreen))
	   (monitor-width-height-in-pixel (current-monitor-pixel-dimensions))
	   (monitor-width (car monitor-width-height-in-pixel))
	   (monitor-height (nth 1 monitor-width-height-in-pixel)))
      (when (eq fullscreen 'maximized)
	(toggle-frame-maximized))
      (set-frame-width frame (- (/ monitor-width 2) 31) nil t)
      (set-frame-height frame (- monitor-height  55) nil t)
      (if left
	  (set-frame-position frame 0 0)
	;; (set-frame-position (selected-frame) (/ (display-pixel-width) 2) 0)
	(let ((frame-width-pixel (frame-native-width frame))
	      (screen-width-pixel (display-pixel-width)))
	  (set-frame-position frame (- monitor-width frame-width-pixel 30) 0))))))

(defun move-frame-top-or-bottom-side (top)
  (when (display-graphic-p)
    (let* ((frame (selected-frame))
	   (fullscreen (frame-parameter frame 'fullscreen))
	   (monitor-width-height-in-pixel (current-monitor-pixel-dimensions))
	   (monitor-width (car monitor-width-height-in-pixel))
	   (monitor-height (nth 1 monitor-width-height-in-pixel)))
      (when (eq fullscreen 'maximized)
	(toggle-frame-maximized))
      (set-frame-height frame (- (/ monitor-height 2) 31) nil t)
      (set-frame-width frame (- monitor-width 50) nil t)
      (if top
	  (set-frame-position frame 0 0)
	(let ((frame-width-pixel (frame-native-width frame))
	      (frame-height-pixel (frame-native-height frame))
	      (screen-width-pixel (display-pixel-width)))
	  (set-frame-position frame 0 (- monitor-height frame-height-pixel 30)))))))

(defun move-frame-to-left-side ()
  "Move frame to left side."
  (interactive)
  (if (display-graphic-p)
      (move-frame-left-or-right-side t)))

(defun move-frame-to-right-side ()
  "Move frame to right side."
  (interactive)
  (if (display-graphic-p)
      (move-frame-left-or-right-side nil)))

(defun move-frame-to-top-side ()
  "Move frame to top side."
  (interactive)
  (if (display-graphic-p)
      (move-frame-top-or-bottom-side t)))

(defun move-frame-to-bottom-side ()
  "Move frame to bottom side."
  (interactive)
  (if (display-graphic-p)
      (move-frame-top-or-bottom-side nil)))

;; preserve smartparens's shortcut
;; (bind-key "C-M-<left>" #'move-frame-to-left-side)
;; (bind-key "C-M-<right>" #'move-frame-to-right-side)

(bind-key "C-M-s-<left>" #'move-frame-to-left-side)
(bind-key "C-M-s-<right>" #'move-frame-to-right-side)
(bind-key "C-M-s-<up>" #'move-frame-to-top-side)
(bind-key "C-M-s-<down>" #'move-frame-to-bottom-side)
#+end_src

* shackle

don't pop windows everywhere!

#+begin_src emacs-lisp

(when (fboundp 'mac-auto-operator-composition-mode)
  (mac-auto-operator-composition-mode))

;; don't pop windows everywhere!
(use-package shackle
  :straight t
  :hook (after-init . shackle-mode)
  :custom
  (shackle-default-size 0.5)
  (shackle-default-alignment 'below)
  (shackle-rules
   '((magit-log-mode       :select t :inhibit-window-quit t :same t)
     ("*quickrun*"         :select t :inhibit-window-quit t :same t)
     (profiler-report-mode :select t)
     (apropos-mode         :select t :align t :size 0.3)
     (help-mode            :select t :align t :size 0.4)
     (comint-mode          :select t :align t :size 0.4)
     (grep-mode            :select t :align t)
     (rg-mode              :select t :align t)
     ("*Flycheck errors*"         :select t   :align t :size 10)
     ("*Backtrace*"               :select t   :align t :size 15)
     ("*ydcv*"                    :select nil :align t :size 0.4)
     ("*Shell Command Output*"    :select nil :align t :size 0.4)
     ("*Async Shell Command*"     :select nil :align t :size 0.4)
     ("*Org-Babel Error Output*"  :select nil :align t :size 0.3)
     ("*package update results*"  :select nil :align t :size 10)
     ("*Process List*"            :select t   :align t :size 0.3)
     ("*Help*"                    :select t   :align t :size 0.3)
     ("*Occur*"                   :select t   :align right)
     ("\\*ivy-occur .*\\*"        :select t   :align right :regexp t)
     ("\\*eldoc\\( for \\)?.*\\*" :select nil :align t :size 15 :regexp t))))
#+end_src

* pair

#+begin_src emacs-lisp

(use-package paredit
    :straight t
    ;; :straight (:type git
    ;;		   :host github
    ;;		   :repo "emacsmirror/paredit")
    :ensure t
    :defer t
    :hook ((;; scheme-mode
	    ;; emacs-lisp-mode lisp-mode ielm-mode
	    clojure-mode cider-repl-mode
	    ;; cask-mode
	    ) . paredit-mode)
    :commands paredit-mode enable-paredit-mode
    ;; :config
    ;; (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
    )

;; electric-pair-mode or smartparens-mode

;; keeps our parentheses balanced and allows for easy manipulation
(use-package smartparens
    :straight t
    :ensure t
    :diminish smartparens-mode
    :commands
    smartparens-strict-mode
    smartparens-mode
    sp-restrict-to-pairs-interactive
    sp-local-pair
    :hook  (after-init . smartparens-global-mode)
    :init
    (setq sp-interactive-dwim t)
    :custom
    (sp-base-key-bindings 'sp)
    ;; (sp-show-pair-from-inside t)
    ;; (sp-autoskip-closing-pair 'always)
    ;; (sp-hybrid-kill-entire-symbol nil)
    ;; (sp-autowrap-region nil)
    :config
    (show-smartparens-global-mode t)
    ;; (smartparens-global-mode t)
    (require 'smartparens-config)
    (sp-use-smartparens-bindings)
    ;; Only use smartparens in web-mode
    (with-eval-after-load 'smartparens
      (setq web-mode-enable-auto-pairing nil)
      (sp-local-pair 'web-mode "<% " " %>")
      (sp-local-pair 'web-mode "{ " " }")
      (sp-local-pair 'web-mode "<%= "  " %>")
      (sp-local-pair 'web-mode "<%# "  " %>")
      (sp-local-pair 'web-mode "<%$ "  " %>")
      (sp-local-pair 'web-mode "<%@ "  " %>")
      (sp-local-pair 'web-mode "<%: "  " %>")
      (sp-local-pair 'web-mode "{{ "  " }}")
      (sp-local-pair 'web-mode "{% "  " %}")
      (sp-local-pair 'web-mode "{%- "  " %}")
      (sp-local-pair 'web-mode "{# "  " #}"))

    (sp-pair "(" ")" :wrap "C-(") ;; how do people live without this?
    (sp-pair "[" "]" :wrap "s-[") ;; C-[ sends ESC
    (sp-pair "{" "}" :wrap "C-{")


    ;; WORKAROUND https://github.com/Fuco1/smartparens/issues/543
    (bind-key "C-<left>" nil smartparens-mode-map)
    (bind-key "C-<right>" nil smartparens-mode-map)

    (bind-key "s-<delete>" 'sp-kill-sexp smartparens-mode-map)
    (bind-key "s-<backspace>" 'sp-backward-kill-sexp smartparens-mode-map)

    ;; ;; fix conflict with move frame left/right side
    ;; (unbind-key "C-M-<left>" smartparens-mode-map)
    ;; (unbind-key "C-M-<right>" smartparens-mode-map)
    )
#+end_src

* rainbow-mode

Visualizing Color Codes with rainbow-mode.

#+begin_src emacs-lisp
(use-package rainbow-mode
    :straight t
    :diminish rainbow-mode
    :commands rainbow-mode
    ;; :init
    ;; (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    )

;; Colored parentheses
(use-package rainbow-delimiters
    :straight t
    :ensure t
    :diminish rainbow-delimiters-mode
    :commands rainbow-delimiters-mode
    :init
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

* highlight indent & parentheses

#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :straight t
  :hook (prog-mode . highlight-indent-guides-mode)
  :delight highlight-indent-guides-mode
  :init
  (setq highlight-indent-guides-method 'character
	highlight-indent-guides-auto-enabled nil
        ;; default is \x2502 but it is very slow on Mac
        highlight-indent-guides-character ?\xFFE8
        highlight-indent-guides-responsive 'top)
  ;; :config
  ;; (set-face-background 'highlight-indent-guides-odd-face "darkgray")
  ;; (set-face-background 'highlight-indent-guides-even-face "dimgray")
  ;; (set-face-foreground 'highlight-indent-guides-character-face "dimgray")
  )

(use-package display-fill-column-indicator
  :if EMACS27+
  :straight nil
  :hook ((prog-mode . display-fill-column-indicator-mode)
         (text-mode . display-fill-column-indicator-mode)))

;; copied from +spacemacs/spacemacs-editing-visual
(use-package highlight-parentheses
  :straight t
  :hook (prog-mode . highlight-parentheses-mode)
  :init
  (setq hl-paren-delay 0.2)
  (setq hl-paren-colors
	'("SpringGreen3" "IndianRed1" "IndianRed3" "IndianRed4"))
  ;; :config
  ;; (set-face-attribute 'hl-paren-face nil :weight 'bold)
  ;; (custom-set-faces '(show-paren-match ((t (:foreground "SpringGreen1" :underline t)))))
  )
#+end_src

* icon

#+begin_src emacs-lisp
(use-package all-the-icons
  :straight t
  :if IS-GUI
  ;; :if (or IS-GUI (daemonp))
  ;; :init
  ;; (setq all-the-icons-scale-factor 0.8)
  )

(use-package all-the-icons-dired
  :straight t
  :if (or (IS-GUI) (daemonp))
  :after (all-the-icons dired)
  :hook (dired-mode . all-the-icons-dired-mode))

(use-package all-the-icons-ibuffer
  :straight t
  :if (or (IS-GUI) (daemonp))
  :after (all-the-icons ibuffer)
  :config
  (all-the-icons-ibuffer-mode t))
#+end_src


* toggle map

#+begin_src emacs-lisp
(define-prefix-command 'toggle-map)
(global-set-key (kbd "\C-c t") 'toggle-map)
(bind-key "t" #'my-toggle-transparency 'toggle-map)
#+end_src

* python

#+begin_src emacs-lisp :tangle no
(use-package jupyter
  :straight (emacs-jupyter :type git :host github :repo "nnicandro/emacs-jupyter")
  :custom
  (jupyter-repl-echo-eval-p t)
  (org-babel-default-header-args:jupyter-python '((:async . "yes")
                                                  (:session . "py")
                                                  (:kernel . "python3")))
  (org-babel-default-header-args:jupyter-julia '((:async . "yes")
                                                 (:session . "jl")
                                                 (:kernel . "julia-1.8")))
  (ob-async-no-async-languages-alist '("python" "jupyter-python" "julia" "jupyter-julia"))
  :bind (("C-c C-x r" . jupyter-repl-restart-kernel)
         ("C-c C-x h" . jupyter-org-restart-and-execute-to-point))
  :config
  (setq jupyter--debug t))

(use-package ob-jupyter
  :defer t
  :straight nil
  :commands (org-babel-execute:jupyter-python)
  :bind
  (:map jupyter-repl-mode-map
        ("C-l" . jupyter-repl-clear-cells)
        ("C-<up>" . jupyter-repl-history-previous)
        ("C-<down>" . jupyter-repl-history-next)))

(use-package zmq
  :custom
  (module-file-suffix ".a")
  :straight(zmq :type git :host github
                :repo "dzop/emacs-zmq"
                :files (:defaults "Makefile" "src" "*.so")))

(use-package simple-httpd
  :straight t)

(setenv "PYDEVD_DISABLE_FILE_VALIDATION" "1")

(use-package ansi-color
  :straight t
  :ensure t
  :init
  (defun colorize-compilation-buffer ()
    (read-only-mode)
    (ansi-color-apply-on-region compilation-filter-start (point))
    (read-only-mode))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))
#+end_src
