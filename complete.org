#+title: complete

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src

** selectrum

#+begin_src emacs-lisp
(use-package selectrum
  :straight t
  :hook (after-init . selectrum-mode)
  :custom
  (selectrum-fix-vertical-window-height t)
  (selectrum-extend-current-candidate-highlight t)
  (selectrum-count-style 'current/matches)
  (selectrum-highlight-candidates-function #'orderless-highlight-matches)
  (selectrum-refine-candidates-function #'orderless-filter)
  ;; (selectrum-num-candidates-displayed 15)
  (selectrum-max-window-height 15)
  :config
  (selectrum-mode t)
  :bind (;; ([remap yank-pop] . my/selectrum-yank-kill-ring)
	 :map selectrum-minibuffer-map
	 ;; ("DEL" . selectrum-backward-kill-sexp)
	 ("<S-backspace>" . selectrum-backward-kill-sexp)
	 ("<down>" . selectrum-next-candidate)
	 ("C-j"  .  selectrum-next-candidate)
	 ("<up>" .  selectrum-previous-candidate)
	 ("C-k"  .  selectrum-previous-candidate)
	 ("<backtab>" . selectrum-previous-candidate)
	 ))
#+end_src

** marginalia

#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :after selectrum
  :ensure t
  :demand t
  :defer 1
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy
			   marginalia-annotators-light))
  :init
  (setq marginalia-command-categories
	'((imenu . imenu)
	  (projectile-find-file . project-file)
	  ;; (projectile-find-file . project)
	  (projectile-find-dir . project-file)
	  ;; (projectile-find-dir . project)
	  ;; (projectile-switch-project . project)
	  (projectile-switch-project . file)
	  (projectile-switch-open-project . file)
	  (projectile-recentf . project-file)
	  (projectile-display-buffer . project-buffer)
	  (projectile-switch-to-buffer . project-buffer)
	  ;; (projectile-commander . project)
	  ))
  :bind (;; ("M-A" . marginalia-cycle)
	 :map minibuffer-local-map
	 ("M-A" . marginalia-cycle))
  :config
  (marginalia-mode)

  ;; Display more annotations - e.g. docstring with M-x
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))

  ;; When using Selectrum, ensure that Selectrum is refreshed when cycling annotations.
  (advice-add #'marginalia-cycle :after
	      (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit)))))

;; -----------------------------------------------------------------------------
;; Marginalia doesn't remember the this-command when switching projects using
;; projectile, since it uses multiple minibuffers. In order to classify project
;; completions properly, we keep track of when we're in the process of switching
;; projects and make sure to return the correct category

(defvar c/switching-project? nil)
(defun c/projectile-before-switch-project ()
  (setq c/switching-project? t))
(defun c/projectile-after-switch-project ()
  (setq c/switching-project? nil))

(after-load (projectile marginalia)
  (add-hook 'projectile-before-switch-project-hook #'c/projectile-before-switch-project)
  (add-hook 'projectile-after-switch-project-hook #'c/projectile-after-switch-project)

  (advice-add 'marginalia-classify-by-prompt :around
	      (lambda (orig-fun &rest args)
		(if c/switching-project?
		    'project
		  (apply orig-fun args)))))
#+end_src

** all-the-icons-completion

#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :straight t
  :after marginalia
  :commands all-the-icons-completion-marginalia-setup
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
  :init
  (all-the-icons-completion-mode))
#+end_src

** Orderless

This is a completion style, it's a back-end for completion and is used by a  front-end that provides a completion UI.

#+begin_src emacs-lisp
;; ordering of narrowed candidates
(use-package orderless
  :straight t
  :after selectrum
  :config
  (setq completion-styles '(orderless))
  (setq orderless-skip-highlighting (lambda () selectrum-is-active)))

;; (use-package orderless
;;   :straight t
;;   :ensure t
;;   :after icomplete
;;   :custom
;;   (orderless-component-separator " +")
;;   (orderless-matching-styles
;;    '(;; The characters of the component should appear in that order in the
;;      ;; candidate, but not necessarily consecutively. This maps 'abc' to
;;      ;; 'a.*b.*c'.
;;      orderless-flex
;;      ;; orderless-initialism = each character of the component should
;;      ;; appear as the beginning of a word in the candidate, in order. This
;;      ;; maps 'abc' to '\<a.*\<b.*\c'.
;;      ;; orderless-strict-initialism = like initialism but only allow
;;      ;; non-letters in between the matched words. 'fb' would match
;;      ;; 'foo-bar' but not 'foo-qux-bar'.
;;      ;; orderless-strict-leading-initialism = like strict-initialism but
;;      ;; require the first initial to match the candidate’s first word. 'bb'
;;      ;; would match 'bar-baz' but not 'foo-bar-baz'.
;;      ;; orderless-strict-full-initialism = like strict-initialism but
;;      ;; require the first initial to match the candidate’s first word. 'bb'
;;      ;; would match 'bar-baz' but not 'foo-bar-baz'.
;;      orderless-strict-leading-initialism
;;      ;; The component is treated as a regexp that must match somewhere in
;;      ;; the candidate.
;;      orderless-regexp
;;      ;; The component is split at word endings and each piece must match at
;;      ;; a word boundary in the candidate, occurring in that order.
;;      orderless-prefixes
;;      ;; The component is treated as a literal string that must occur in the
;;      ;; candidate.
;;      orderless-literal))
;;   (orderless-skip-highlighting (lambda () selectrum-is-active))
;;   :config
;;   (defun my/match-components-literally ()
;;     "Components match literally for the rest of the session."
;;     (interactive)
;;     (setq-local
;;      orderless-matching-styles '(orderless-literal)
;;      completion-styles '(orderless)
;;      ;; orderless-matching-styles '(orderless-strict-initialism)
;;      orderless-style-dispatchers nil))
;;   :bind
;;   (:map minibuffer-local-completion-map
;;	("C-l" . my/match-components-literally)))

;; ;; '=' at the end of a component will make this component match as a literal.
;; (defun my/orderless-literal-dispatcher (pattern _index _total)
;;   (when (string-suffix-p "=" pattern)
;;     `(orderless-literal . ,(substring pattern 0 -1))))

;; ;; ',' at the end of a component will make this component match as a strict
;; ;; leading initialism.
;; (defun my/orderless-initialism-dispatcher (pattern _index _total)
;;   (when (string-suffix-p "," pattern)
;;     `(orderless-strict-leading-initialism . ,(substring pattern 0 -1))))

;; (setq orderless-style-dispatchers
;;       '(my/orderless-literal-dispatcher
;;         my/orderless-initialism-dispatcher))
#+end_src

** selectrum-prescient

#+begin_src  emacs-lisp
(use-package selectrum-prescient
  :straight t
  :after selectrum
  :config
  (selectrum-prescient-mode t)
  (prescient-persist-mode))
#+end_src

** Consult without consultation fees

#+begin_src emacs-lisp
(use-package consult
  :straight t
  :ensure t
  :demand t
  :after selectrum
  :defer 1
  ;; :custom
  ;; (consult-preview-key nil)
  ;; (consult-project-root-function #'projectile-project-root)
  :hook
  (completion-list-mode . consult-preview-at-point-mode)
  :init (bind-key "TAB"
		  (lambda ()
		    (interactive)
		    (isearch-exit)
		    (consult-line isearch-string))
		  isearch-mode-map)
  :config
  (require 'consult)
  (require 'consult-imenu)
  (with-eval-after-load 'org
    (require 'consult-org))
  (declare-function consult--customize-set "consult")
  (progn
    (setq consult-project-root-function #'vc-root-dir)
    (consult-customize
     consult-ripgrep consult-grep
     consult-buffer consult-recent-file
     :preview-key (kbd "M-."))

    ;; Disable consult-buffer project-related capabilities as
    ;; they are very slow in TRAMP.
    (setq consult-buffer-sources
	  (delq 'consult--source-project-buffer
		(delq 'consult--source-project-file consult-buffer-sources)))

    (setq consult--source-hidden-buffer
	  (plist-put consult--source-hidden-buffer :narrow ?h)))
  :bind (
   ("M-s f" . consult-line)
	 ("M-g g" . consult-line)
	 ("M-g o" . consult-outline)
	 ("M-g i" . consult-imenu)
	 ("M-g r" . consult-ripgrep)
	 ("C-x C-r" . consult-recent-file)
   ([remap yank-pop] . consult-yank-from-kill-ring)
   ([remap switch-to-buffer] . consult-buffer)
   ([remap goto-line] . consult-goto-line)))

(use-package deadgrep
  :ensure t
  :commands (deadgrep--read-search-term)
  :bind (("C-c s" . deadgrep)))
#+end_src

** vertico
#+begin_src emacs-lisp
(use-package vertico
  :straight (vertico
	     :files (:defaults "extensions/*")
	     :includes (vertico-buffer
			vertico-directory
			vertico-flat
			vertico-indexed
			vertico-mouse
			vertico-quick
			vertico-repeat
			vertico-reverse))
  ;; :straight t
  :init
  (vertico-mode)
  :config
  ;; Different scroll margin
  ;; (setq vertico-scroll-margin 0)

  ;; Show more candidates
  ;; (setq vertico-count 20)

  ;; Grow and shrink the Vertico minibuffer
  ;; (setq vertico-resize t)

  ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
  (setq vertico-cycle t)
  )

;; Configure directory extension.
(use-package vertico-directory
  :straight nil
  :after vertico
  :ensure nil
  ;; More convenient directory navigation commands
  :bind (:map vertico-map
	      ("RET" . vertico-directory-enter)
	      ("DEL" . vertico-directory-delete-char)
	      ("M-DEL" . vertico-directory-delete-word)
	      ("<S-backspace>" . vertico-directory-delete-word))
  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))


;; Optionally use the `orderless' completion style. See
;; `+orderless-dispatch' in the Consult wiki for an advanced Orderless style
;; dispatcher. Additionally enable `partial-completion' for file path
;; expansion. `partial-completion' is important for wildcard support.
;; Multiple files can be opened at once with `find-file' if you enter a
;; wildcard. You may also give the `initials' completion style a try.
(use-package orderless
  :init
  ;; Configure a custom style dispatcher (see the Consult wiki)
  ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
  ;;       orderless-component-separator #'orderless-escapable-split-on-space)
  (setq completion-styles '(orderless) ;; basic
	completion-category-defaults nil
	completion-category-overrides '((file (styles partial-completion)))))

;; A few more useful configurations...
(use-package emacs
  :straight nil
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; Alternatively try `consult-completing-read-multiple'.
  (defun crm-indicator (args)
    (cons (concat "[CRM] " (car args)) (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
	'(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  ;; Vertico commands are hidden in normal buffers.
  ;; (setq read-extended-command-predicate
  ;;       #'command-completion-default-include-p)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t))

(define-key vertico-map "?" #'minibuffer-completion-help)
(define-key vertico-map (kbd "M-RET") #'minibuffer-force-complete-and-exit)
(define-key vertico-map (kbd "M-TAB") #'minibuffer-complete)
#+end_src


** corfu

#+begin_src emacs-lisp
(use-package corfu
    :straight (
	       :files (:defaults "extensions/*")
	       :includes (corfu-history))
    :bind (:map corfu-map
		("TAB" . corfu-next)
		("C-n" . corfu-next)
		("<tab>" . corfu-next)
		("S-TAB" . corfu-previous)
		("C-p" . corfu-previous)
		("<backtab>" . corfu-previous)
		("RET"     . corfu-insert)
		("<return>"  . corfu-insert)
		("<escape>" . corfu-quit)
		;; ("ESC"    . corfu-reset)
		;; ("SPC" . corfu-move-to-minibuffer)
		;; ("<space>" . corfu-move-to-minibuffer)
		;; ([remap completion-at-point] . corfu-next)
		)
    :custom
    (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-auto t)                 ;; Enable auto completion
    (corfu-count 10) ;; Max # of candidates to show
    (corfu-commit-predicate nil)
    (corfu-auto-delay 0.4)
    (corfu-auto-prefix 2)
    (corfu-quit-at-boundary nil)
    (corfu-separator ?\s)          ;; Orderless field separator
    (corfu-quit-no-match t)
    ;; (corfu-preview-current t)
    (corfu-preview-current 'insert)       ; First candidate as overlay. Insert on input if only one
    (corfu-quit-at-boundary 'separator)   ; Boundary: stay alive if separator inserted
    (corfu-quit-no-match 'separator)      ; No match: stay alive if separator inserted
    (corfu-preselect-first t)
    ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
    ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area
    ;; (corfu-echo-documentation '(1.0 . 0.2))
    (corfu-min-width 30)
    ;; (corfu-min-width 99)
    ;; hide scroll-bar
    (corfu-bar-width 0)
    (corfu-right-margin-width 0)
    (corfu-scroll-margin 5)        ;; Use scroll margin
    ;; :hook (after-init-hook . global-corfu-mode)
    :init
    (global-corfu-mode))

  ;; (unless (display-graphic-p)
  ;;   (use-package popon
  ;;     :straight (popon
  ;;	       :type git
  ;;	       :repo "https://codeberg.org/akib/emacs-popon.git"))
  ;;   (use-package corfu-popup
  ;;     :straight (corfu-popup
  ;;	       :type git
  ;;	       :repo "https://codeberg.org/akib/emacs-corfu-popup.git")
  ;;     :init
  ;;     (corfu-popup-mode +1)))

  ;; Icon support
  (use-package kind-icon
    :ensure t
    :straight t
    :after corfu
    :custom
    (kind-icon-default-face 'corfu-default)
    (kind-icon-use-icon t)
    (kind-icon-blend-background nil)
    (kind-icon-blend-frac 0.08)
    (svg-lib-icons-dir (expand-file-name "svg-lib" poly-cache-dir))
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
    (setq kind-icon-mapping
	  '((array "a" :icon "code-brackets" :face font-lock-type-face)
	    (boolean "b" :icon "circle-half-full" :face font-lock-builtin-face)
	    (class "c" :icon "video-input-component" :face font-lock-type-face) ;
	    (color "#" :icon "palette" :face success) ;
	    (constant "co" :icon "square-circle" :face font-lock-constant-face) ;
	    (constructor "cn" :icon "cube-outline" :face font-lock-function-name-face) ;
	    (enum-member "em" :icon "format-align-right" :face font-lock-builtin-face) ;
	    (enum "e" :icon "server" :face font-lock-builtin-face) ;
	    (event "ev" :icon "zip-box-outline" :face font-lock-warning-face) ;
	    (field "fd" :icon "tag" :face font-lock-variable-name-face) ;
	    (file "f" :icon "file-document-outline" :face font-lock-string-face) ;
	    (folder "d" :icon "folder" :face font-lock-doc-face) ;
	    (interface "if" :icon "share-variant" :face font-lock-type-face) ;
	    (keyword "kw" :icon "image-filter-center-focus" :face font-lock-keyword-face) ;
	    (macro "mc" :icon "lambda" :face font-lock-keyword-face)
	    (method "m" :icon "cube-outline" :face font-lock-function-name-face) ;
	    (function "f" :icon "cube-outline" :face font-lock-function-name-face) ;
	    (module "{" :icon "view-module" :face font-lock-preprocessor-face) ;
	    (numeric "nu" :icon "numeric" :face font-lock-builtin-face)
	    (operator "op" :icon "plus-circle-outline" :face font-lock-comment-delimiter-face) ;
	    (param "pa" :icon "tag" :face default)
	    (property "pr" :icon "wrench" :face font-lock-variable-name-face) ;
	    (reference "rf" :icon "collections-bookmark" :face font-lock-variable-name-face) ;
	    (snippet "S" :icon "format-align-center" :face font-lock-string-face) ;
	    (string "s" :icon "sticker-text-outline" :face font-lock-string-face)
	    (struct "%" :icon "video-input-component" :face font-lock-variable-name-face) ;
	    (text "tx" :icon "format-text" :face shadow)
	    (type-parameter "tp" :icon "format-list-bulleted-type" :face font-lock-type-face)
	    (unit "u" :icon "ruler-square" :face shadow)
	    (value "v" :icon "format-align-right" :face font-lock-builtin-face) ;
	    (variable "va" :icon "tag" :face font-lock-variable-name-face)
	    (t "." :icon "file-find" :face shadow)))
    )

  ;; A few more useful configurations...
  (use-package emacs
    :init
    (setq compilation-scroll-output 'first-error)
    (setq auto-revert-check-vc-info t)
    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)

    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete))

  (use-package corfu-history
    :after corfu
    :init (corfu-history-mode))

  ;; Completion At Point Extensions made for `corfu'
  (use-package cape
    :straight t
    ;; ;; Bind dedicated completion commands
    ;; ;; Alternative prefix keys: C-c p, M-p, M-+, ...
    ;; :bind (("C-c p p" . completion-at-point) ;; capf
    ;;        ("C-c p t" . complete-tag)        ;; etags
    ;;        ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
    ;;        ("C-c p h" . cape-history)
    ;;        ("C-c p f" . cape-file)
    ;;        ("C-c p k" . cape-keyword)
    ;;        ("C-c p s" . cape-symbol)
    ;;        ("C-c p a" . cape-abbrev)
    ;;        ("C-c p i" . cape-ispell)
    ;;        ("C-c p l" . cape-line)
    ;;        ("C-c p w" . cape-dict)
    ;;        ("C-c p \\" . cape-tex)
    ;;        ("C-c p _" . cape-tex)
    ;;        ("C-c p ^" . cape-tex)
    ;;        ("C-c p &" . cape-sgml)
    ;;        ("C-c p r" . cape-rfc1345))
    :init
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-tex)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    ;; (add-to-list 'completion-at-point-functions #'cape-keyword)
    ;; (add-to-list 'completion-at-point-functions #'cape-sgml)
    ;; (add-to-list 'completion-at-point-functions #'cape-rfc1345)
    (add-to-list 'completion-at-point-functions #'cape-ispell)
    ;; (add-to-list 'completion-at-point-functions #'cape-dict)
    (add-to-list 'completion-at-point-functions #'cape-symbol)
    (add-to-list 'completion-at-point-functions #'cape-line)
    :hook ((prog-mode . my/set-basic-capf)
	   (org-mode . my/set-basic-capf)
	   ((lsp-completion-mode eglot-managed-mode) . my/set-lsp-capf))
    :config
    (setq dabbrev-upcase-means-case-search t)
    (setq case-fold-search nil)
    ;; (setq cape-dict-file "/usr/share/dict/words")
    ;; Silence the pcomplete capf, no errors or messages!
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)
    ;; Ensure that pcomplete does not write to the buffer
    ;; and behaves as a pure `completion-at-point-function'.
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))

  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      ;; (setq-local corfu-auto nil) Enable/disable auto completion
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)

  (defun corfu-move-to-minibuffer ()
    (interactive)
    (let ((completion-extra-properties corfu--extra)
	  completion-cycle-threshold completion-cycling)
      (apply #'consult-completion-in-region completion-in-region--data)))
  (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer)

  (use-package corfu-doc
    :ensure t
    :straight t
    :config
    ;;hook
    (add-hook 'corfu-mode-hook #'corfu-doc-mode)
    ;;bind
    (define-key corfu-map (kbd "M-p") #'corfu-doc-scroll-down) ;; corfu-next
    (define-key corfu-map (kbd "M-n") #'corfu-doc-scroll-up)  ;; corfu-previous
    (define-key corfu-map (kbd "M-d") #'corfu-doc-toggle))

  ;; Configure Tempel
  (use-package tempel
    :straight t
    ;; Require trigger prefix before template name when completing.
    ;; :custom
    ;; (tempel-trigger-prefix "<")

    :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
	   ("M-*" . tempel-insert))
    :init

    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; `tempel-expand' only triggers on exact matches. Alternatively use
      ;; `tempel-complete' if you want to see all matches, but then you
      ;; should also configure `tempel-trigger-prefix', such that Tempel
      ;; does not trigger too often when you don't expect it. NOTE: We add
      ;; `tempel-expand' *before* the main programming mode Capf, such
      ;; that it will be tried first.
      (setq-local completion-at-point-functions
		  (cons #'tempel-expand
			completion-at-point-functions)))

    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)

    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    ;; (global-tempel-abbrev-mode)
    )

  (use-package tabnine-capf
    :after cape
    :straight (:host github :repo "50ways2sayhard/tabnine-capf" :files ("*.el" "*.sh"))
    :hook (kill-emacs . tabnine-capf-kill-process)
    :config
    (add-to-list 'completion-at-point-functions #'tabnine-completion-at-point))

  ;; https://github.com/50ways2sayhard/.emacs.d/blob/1158200665431cc336c868ad1f9ecb43c249fc31/elisp/init-complete.el
  (defun my/convert-super-capf (arg-capf)
    (list
     ;; #'cape-file
     ;; #'cape-dabbrev
     ;; #'cape-keyword
     ;; #'cape-symbol
     (cape-capf-buster
      (cape-super-capf
       ;; #'tempel-expand
       ;; #'tabnine-completion-at-point
       arg-capf
       )
      )
     ;; #'cape-dabbrev
     ))

  (defun my/set-basic-capf ()
    (setq completion-category-defaults nil)
    (setq-local completion-at-point-functions
		(my/convert-super-capf
		 (car completion-at-point-functions))))

  (defun my/set-lsp-capf ()
    (setq completion-category-defaults nil)
    (setq-local completion-at-point-functions
		(my/convert-super-capf (if poly-use-lsp-mode
					   #'lsp-completion-at-point
					 #'eglot-completion-at-point))))
#+end_src
